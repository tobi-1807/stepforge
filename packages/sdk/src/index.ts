import { WorkflowDefinition, WorkflowBuilder, WorkflowGraph, GraphNode, GraphEdge, StepFn } from "./types.js";
export * from "./types.js";

export function defineWorkflow(def: WorkflowDefinition): WorkflowDefinition {
    return def;
}

// Shared ID generation logic
function generateNodeId(version: string, logicalPath: string) {
    const content = `${version}:${logicalPath}`;
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
        hash = (hash << 5) - hash + content.charCodeAt(i);
        hash |= 0;
    }
    return "n_" + (hash >>> 0).toString(16);
}

// Logic to build the graph from the definition
export function buildGraph(def: WorkflowDefinition, workflowId: string, version: string): WorkflowGraph {
    const nodes: Record<string, GraphNode> = {};
    const edges: GraphEdge[] = [];

    const rootId = "root"; // Root node is special, not generated by logical path
    nodes[rootId] = {
        id: rootId,
        kind: "root",
        title: def.name,
        nodes: [],
    } as any;

    const traverse = (
        builderFn: (b: WorkflowBuilder) => void,
        parentId: string | null,
        parentPath: string,
        previousNodeId: string | null
    ): string | null => {

        let lastNodeInScope = previousNodeId;

        const scopeBuilder: WorkflowBuilder = {
            step(title, fn, options) {
                const logicalPath = parentPath ? `${parentPath}/${title}` : title;
                const id = generateNodeId(version, logicalPath);

                nodes[id] = {
                    id,
                    kind: "step",
                    title,
                    parentId,
                    meta: options
                };

                // Sequence dependency
                if (lastNodeInScope) {
                    edges.push({ from: lastNodeInScope, to: id, type: "sequence" });
                } else if (parentId && parentId !== rootId) {
                    // Group handling
                }

                lastNodeInScope = id;
            },
            group(title, fn, options) {
                const logicalPath = parentPath ? `${parentPath}/${title}` : title;
                const id = generateNodeId(version, logicalPath);

                nodes[id] = {
                    id,
                    kind: "group",
                    title,
                    parentId,
                    meta: options
                };

                if (lastNodeInScope) {
                    edges.push({ from: lastNodeInScope, to: id, type: "sequence" });
                }

                traverse(fn, id, logicalPath, null);

                lastNodeInScope = id;
            }
        };

        builderFn(scopeBuilder);
        return lastNodeInScope;
    };

    traverse(def.build, rootId, "", null);


    return {
        workflowId,
        name: def.name,
        version,
        rootId,
        nodes,
        edges
    };
}

export async function executeWorkflow(
    def: WorkflowDefinition,
    version: string,
    context: {
        runId: string,
        onEvent: (evt: any) => void,
        inputs?: Record<string, any>,
        onControlStateChange?: (state: import('./types.js').RunControlState) => void,
        getControlSignal?: () => import('./types.js').RunControlSignal | null
    }
) {
    const { runId, onEvent, inputs = {}, onControlStateChange, getControlSignal } = context;

    // Execution Context State
    let isCancelled = false;
    let isPaused = false;
    const runState = new Map<string, unknown>();
    const failedSteps: Array<{ nodeId: string; error: string }> = [];

    // Initialize runState with inputs
    Object.entries(inputs).forEach(([key, value]) => {
        runState.set(key, value);
    });

    // Helper to emit control state
    const emitControlState = (pausedAt?: string) => {
        const state: import('./types.js').RunControlState = {
            signal: getControlSignal?.() || null,
            pausedAt,
            failedSteps
        };
        onControlStateChange?.(state);
        onEvent({ type: 'run:control_state', runId, state });
    };

    // Helper to wait while paused
    const waitIfPausedHelper = async (nodeId: string) => {
        const signal = getControlSignal?.();
        if (signal === 'pause') {
            if (!isPaused) {
                isPaused = true;
                onEvent({ type: 'run:paused', runId, nodeId, at: new Date().toISOString() });
                emitControlState(nodeId);
            }

            // Wait until resume or cancel
            while (true) {
                await new Promise(resolve => setTimeout(resolve, 100));
                const currentSignal = getControlSignal?.();

                if (currentSignal === 'resume') {
                    isPaused = false;
                    onEvent({ type: 'run:resumed', runId, at: new Date().toISOString() });
                    emitControlState();
                    break;
                }

                if (currentSignal === 'cancel') {
                    isCancelled = true;
                    break;
                }
            }
        }

        if (getControlSignal?.() === 'cancel') {
            isCancelled = true;
        }
    };

    const traverseAndExecute = async (
        buildFn: (b: WorkflowBuilder) => void,
        parentPath: string,
        parentId: string | null
    ) => {

        const items: Array<{
            type: 'step' | 'group',
            title: string,
            fn?: StepFn,
            buildFn?: (b: WorkflowBuilder) => void,
            options?: any
        }> = [];

        const builder: WorkflowBuilder = {
            step(title, fn, options) {
                items.push({ type: 'step', title, fn, options });
            },
            group(title, buildFn, options) {
                items.push({ type: 'group', title, buildFn, options });
            }
        };

        buildFn(builder);

        for (const item of items) {
            if (isCancelled) break;

            const logicalPath = parentPath ? `${parentPath}/${item.title}` : item.title;
            const nodeId = generateNodeId(version, logicalPath);
            const nodeTitle = item.title;

            // Check for pause/cancel before each step
            await waitIfPausedHelper(nodeId);
            if (isCancelled) break;

            if (item.type === 'step' && item.fn) {
                onEvent({ type: 'node:start', nodeId, nodeTitle, at: new Date().toISOString() });

                const ctx: import('./types.js').StepContext = {
                    nodeId,
                    runId,
                    log: {
                        info: (msg, data) => onEvent({ type: 'node:log', nodeId, nodeTitle, level: 'info', msg, data }),
                        warn: (msg, data) => onEvent({ type: 'node:log', nodeId, nodeTitle, level: 'warn', msg, data }),
                        error: (msg, data) => onEvent({ type: 'node:log', nodeId, nodeTitle, level: 'error', msg, data }),
                        debug: (msg, data) => onEvent({ type: 'node:log', nodeId, nodeTitle, level: 'debug', msg, data }),
                    },
                    progress: (p) => onEvent({ type: 'node:progress', nodeId, nodeTitle, data: p }),
                    artifact: (a) => onEvent({ type: 'node:artifact', nodeId, nodeTitle, data: a }),
                    output: (o) => onEvent({ type: 'node:output', nodeId, nodeTitle, data: o }),
                    isCancelled: () => isCancelled,
                    throwIfCancelled: () => { if (isCancelled) throw new Error("Cancelled"); },
                    isPaused: () => isPaused,
                    waitIfPaused: async () => await waitIfPausedHelper(nodeId),
                    run: {
                        get: (key) => runState.get(key) as any,
                        set: (key, value) => { runState.set(key, value); },
                        require: (key) => {
                            if (!runState.has(key)) throw new Error(`Missing required run key: ${key}`);
                            return runState.get(key) as any;
                        }
                    }
                };

                try {
                    await item.fn(ctx);
                    onEvent({ type: 'node:end', nodeId, nodeTitle, status: 'success', at: new Date().toISOString() });
                    // Remove from failed steps if it was there (retry success)
                    const failedIndex = failedSteps.findIndex(f => f.nodeId === nodeId);
                    if (failedIndex >= 0) {
                        failedSteps.splice(failedIndex, 1);
                        emitControlState();
                    }
                } catch (e: any) {
                    onEvent({ type: 'node:end', nodeId, nodeTitle, status: 'failure', error: e.message, at: new Date().toISOString() });
                    // Track failed step
                    const existingFailed = failedSteps.find(f => f.nodeId === nodeId);
                    if (existingFailed) {
                        existingFailed.error = e.message;
                    } else {
                        failedSteps.push({ nodeId, error: e.message });
                    }
                    emitControlState();
                    throw e;
                }

            } else if (item.type === 'group' && item.buildFn) {
                onEvent({ type: 'node:start', nodeId, nodeTitle, at: new Date().toISOString() });

                try {
                    await traverseAndExecute(item.buildFn, logicalPath, nodeId);
                    onEvent({ type: 'node:end', nodeId, nodeTitle, status: 'success', at: new Date().toISOString() });
                } catch (e: any) {
                    onEvent({ type: 'node:end', nodeId, nodeTitle, status: 'failure', error: e.message, at: new Date().toISOString() });
                    throw e;
                }
            }
        }
    };

    try {
        const rootId = "root";
        onEvent({ type: 'node:start', nodeId: rootId, nodeTitle: def.name, at: new Date().toISOString() });
        await traverseAndExecute(def.build, "", rootId);
        onEvent({ type: 'node:end', nodeId: rootId, nodeTitle: def.name, status: 'success', at: new Date().toISOString() });
    } catch (e) {
        const rootId = "root";
        onEvent({ type: 'node:end', nodeId: rootId, nodeTitle: def.name, status: 'failure', at: new Date().toISOString() });
        throw e;
    }
}
