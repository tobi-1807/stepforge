import {
  WorkflowDefinition,
  WorkflowBuilder,
  WorkflowGraph,
  GraphNode,
  GraphEdge,
  StepFn,
  IterationStepFn,
  MapOptions,
  LoopBuilder,
  StepNodeOptions,
  IterationStepContext,
  InputParameter,
  InferInputs,
} from "./types.js";
export * from "./types.js";

/**
 * Helper to define workflow inputs with automatic literal type inference.
 * Replaces the need for `as const`.
 *
 * @example
 * ```ts
 * inputs([
 *   { name: "count", type: "number", label: "Count", default: 5 }
 * ])
 * ```
 */
export function inputs<const T extends readonly InputParameter[]>(defs: T): T {
  return defs;
}


/**
 * Define a workflow with minimal ceremony.
 *
 * Overloads:
 * - `workflow(name, build)` – no inputs, `ctx.inputs` is `{}`
 * - `workflow(name, inputs([...]), build)` – typed inputs via `inputs()` helper
 *
 * @example
 * ```ts
 * // Simple workflow (no inputs)
 * export default workflow("Hello", (wf) => {
 *   wf.step("Greet", async (ctx) => {
 *     ctx.log.info("Hello world!");
 *   });
 * });
 *
 * // Workflow with typed inputs via helper (preferred)
 * export default workflow(
 *   "Counter",
 *   inputs([
 *     { name: "count", type: "number", label: "Count", default: 5 }
 *   ]),
 *   (wf) => {
 *     wf.step("Process", async (ctx) => {
 *       ctx.log.info(`Count is ${ctx.inputs.count}`);
 *     });
 *   }
 * );
 * ```
 */
export function workflow(
  name: string,
  build: (wf: WorkflowBuilder<{}>) => void
): WorkflowDefinition<[]>;
export function workflow<const TInputsDef extends readonly InputParameter[]>(
  name: string,
  inputs: TInputsDef,
  build: (wf: WorkflowBuilder<InferInputs<TInputsDef>>) => void
): WorkflowDefinition<TInputsDef>;
export function workflow<const TInputsDef extends readonly InputParameter[]>(
  name: string,
  inputsOrBuild: TInputsDef | ((wf: WorkflowBuilder<any>) => void),
  maybeBuild?: (wf: WorkflowBuilder<InferInputs<TInputsDef>>) => void
): WorkflowDefinition<TInputsDef> {
  if (typeof inputsOrBuild === "function") {
    // workflow(name, build)
    return { name, build: inputsOrBuild } as WorkflowDefinition<TInputsDef>;
  }
  // workflow(name, inputs, build)
  return {
    name,
    inputs: inputsOrBuild,
    build: maybeBuild!,
  } as WorkflowDefinition<TInputsDef>;
}

// Shared ID generation logic
function generateNodeId(version: string, logicalPath: string) {
  const content = `${version}:${logicalPath}`;
  let hash = 0;
  for (let i = 0; i < content.length; i++) {
    hash = (hash << 5) - hash + content.charCodeAt(i);
    hash |= 0;
  }
  return "n_" + (hash >>> 0).toString(16);
}

// Logic to build the graph from the definition
export function buildGraph(
  def: WorkflowDefinition,
  workflowId: string,
  version: string
): WorkflowGraph {
  const nodes: Record<string, GraphNode> = {};
  const edges: GraphEdge[] = [];

  const rootId = "root"; // Root node is special, not generated by logical path
  nodes[rootId] = {
    id: rootId,
    kind: "root",
    title: def.name,
    nodes: [],
  } as any;

  const traverse = (
    builderFn: (b: WorkflowBuilder) => void,
    parentId: string | null,
    parentPath: string,
    previousNodeId: string | null
  ): string | null => {
    let lastNodeInScope = previousNodeId;

    const scopeBuilder: WorkflowBuilder = {
      step(title, fn, options) {
        const logicalPath = parentPath ? `${parentPath}/${title}` : title;
        const id = generateNodeId(version, logicalPath);

        nodes[id] = {
          id,
          kind: "step",
          title,
          parentId,
          meta: options,
        };

        // Sequence dependency
        if (lastNodeInScope) {
          edges.push({ from: lastNodeInScope, to: id, type: "sequence" });
        } else if (parentId && parentId !== rootId) {
          // Group handling
        }

        lastNodeInScope = id;
      },
      group(title, fn, options) {
        const logicalPath = parentPath ? `${parentPath}/${title}` : title;
        const id = generateNodeId(version, logicalPath);

        nodes[id] = {
          id,
          kind: "group",
          title,
          parentId,
          meta: options,
        };

        if (lastNodeInScope) {
          edges.push({ from: lastNodeInScope, to: id, type: "sequence" });
        }

        traverse(fn, id, logicalPath, null);

        lastNodeInScope = id;
      },
      map<T>(
        title: string,
        opts: MapOptions<T>,
        buildTemplate: (loop: LoopBuilder<any, T>) => void
      ) {
        const logicalPath = parentPath ? `${parentPath}/${title}` : title;
        const mapNodeId = generateNodeId(version, logicalPath);

        // Create the map node
        nodes[mapNodeId] = {
          id: mapNodeId,
          kind: "map",
          title,
          parentId,
          meta: {
            map: {
              onError: opts.onError ?? "fail-fast",
              maxConcurrency: opts.maxConcurrency ?? 1,
            },
          },
        };

        // Sequence dependency from previous sibling
        if (lastNodeInScope) {
          edges.push({
            from: lastNodeInScope,
            to: mapNodeId,
            type: "sequence",
          });
        }

        // Traverse template steps using a LoopBuilder
        // We call buildTemplate once in "template mode" with dummy values
        // The template step titles must be static (not dependent on item)
        let lastTemplateNodeId: string | null = null;

        const loopBuilder: LoopBuilder<any, any> = {
          step(
            stepTitle: string,
            _fn: IterationStepFn<any, any>,
            stepOptions?: StepNodeOptions
          ) {
            const templateLogicalPath = `${logicalPath}/${stepTitle}`;
            const templateNodeId = generateNodeId(version, templateLogicalPath);

            nodes[templateNodeId] = {
              id: templateNodeId,
              kind: "step",
              title: stepTitle,
              parentId: mapNodeId,
              meta: stepOptions,
            };

            // Sequence edges between template steps
            if (lastTemplateNodeId) {
              edges.push({
                from: lastTemplateNodeId,
                to: templateNodeId,
                type: "sequence",
              });
            }

            lastTemplateNodeId = templateNodeId;
          },
        };

        // Call buildTemplate to discover template structure
        buildTemplate(loopBuilder);

        lastNodeInScope = mapNodeId;
      },
    };

    builderFn(scopeBuilder);
    return lastNodeInScope;
  };

  traverse(def.build, rootId, "", null);

  return {
    workflowId,
    name: def.name,
    version,
    rootId,
    nodes,
    edges,
  };
}

export async function executeWorkflow(
  def: WorkflowDefinition,
  version: string,
  context: {
    runId: string;
    onEvent: (evt: any) => void;
    inputs?: Record<string, any>;
    onControlStateChange?: (
      state: import("./types.js").RunControlState
    ) => void;
    getControlSignal?: () => import("./types.js").RunControlSignal | null;
  }
) {
  const {
    runId,
    onEvent,
    inputs = {},
    onControlStateChange,
    getControlSignal,
  } = context;

  // Execution Context State
  let isCancelled = false;
  let isPaused = false;
  const runState = new Map<string, unknown>();
  const failedSteps: Array<{ nodeId: string; error: string }> = [];
  const outputs: Record<string, any> = {};
  const mapOutputs: Record<string, Record<string, Record<string, any>>> = {};

  // Iteration-scoped stores (keyed by iterationId)
  const iterationStores = new Map<string, Map<string, unknown>>();

  // Helper to generate a simple hash string from a key (for stable iterationIds)
  const hashKey = (key: string): string => {
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      hash = (hash << 5) - hash + key.charCodeAt(i);
      hash |= 0;
    }
    return (hash >>> 0).toString(16);
  };

  // Helper to create an iteration-scoped store
  const createIterationStore = (
    iterationId: string
  ): import("./types.js").RunStore => {
    let store = iterationStores.get(iterationId);
    if (!store) {
      store = new Map<string, unknown>();
      iterationStores.set(iterationId, store);
    }
    return {
      get: (key) => store!.get(key) as any,
      set: (key, value) => {
        store!.set(key, value);
      },
      require: (key) => {
        if (!store!.has(key))
          throw new Error(`Missing required iteration key: ${key}`);
        return store!.get(key) as any;
      },
    };
  };

  // Helper to clear iteration store (called after each iteration completes)
  const clearIterationStore = (iterationId: string) => {
    iterationStores.delete(iterationId);
  };

  // Helper to emit control state
  const emitControlState = (pausedAt?: string) => {
    const state: import("./types.js").RunControlState = {
      signal: getControlSignal?.() || null,
      pausedAt,
      failedSteps,
      outputs,
      mapOutputs,
    };
    onControlStateChange?.(state);
    onEvent({ type: "run:control_state", runId, state });
  };

  // Helper to wait while paused
  const waitIfPausedHelper = async (nodeId: string) => {
    const signal = getControlSignal?.();
    if (signal === "pause") {
      if (!isPaused) {
        isPaused = true;
        onEvent({
          type: "run:paused",
          runId,
          nodeId,
          at: new Date().toISOString(),
        });
        emitControlState(nodeId);
      }

      // Wait until resume or cancel
      while (true) {
        await new Promise((resolve) => setTimeout(resolve, 100));
        const currentSignal = getControlSignal?.();

        if (currentSignal === "resume") {
          isPaused = false;
          onEvent({ type: "run:resumed", runId, at: new Date().toISOString() });
          emitControlState();
          break;
        }

        if (currentSignal === "cancel") {
          isCancelled = true;
          break;
        }
      }
    }

    if (getControlSignal?.() === "cancel") {
      isCancelled = true;
    }
  };

  // Helper for ctx.sleep
  const sleepHelper = async (ms: number, nodeId: string) => {
    const start = Date.now();
    while (Date.now() - start < ms) {
      if (isCancelled) throw new Error("Cancelled");
      await waitIfPausedHelper(nodeId);
      if (isCancelled) throw new Error("Cancelled");

      const remaining = ms - (Date.now() - start);
      if (remaining <= 0) break;

      // Check every 100ms or remaining time
      await new Promise((resolve) =>
        setTimeout(resolve, Math.min(100, remaining))
      );
    }
  };

  // Helper to create a run store interface
  const createRunStore = (): import("./types.js").RunStore => ({
    get: (key) => runState.get(key) as any,
    set: (key, value) => {
      runState.set(key, value);
    },
    require: (key) => {
      if (!runState.has(key))
        throw new Error(`Missing required run key: ${key}`);
      return runState.get(key) as any;
    },
  });

  // Helper to create a log interface for a node
  const createLogInterface = (nodeId: string, nodeTitle: string) => ({
    info: (msg: string, data?: any) =>
      onEvent({
        type: "node:log",
        nodeId,
        nodeTitle,
        level: "info",
        msg,
        data,
      }),
    warn: (msg: string, data?: any) =>
      onEvent({
        type: "node:log",
        nodeId,
        nodeTitle,
        level: "warn",
        msg,
        data,
      }),
    error: (msg: string, data?: any) =>
      onEvent({
        type: "node:log",
        nodeId,
        nodeTitle,
        level: "error",
        msg,
        data,
      }),
    debug: (msg: string, data?: any) =>
      onEvent({
        type: "node:log",
        nodeId,
        nodeTitle,
        level: "debug",
        msg,
        data,
      }),
  });

  const traverseAndExecute = async (
    buildFn: (b: WorkflowBuilder) => void,
    parentPath: string,
    parentId: string | null
  ) => {
    const items: Array<{
      type: "step" | "group" | "map";
      title: string;
      fn?: StepFn;
      buildFn?: (b: WorkflowBuilder) => void;
      mapOpts?: MapOptions<any>;
      mapBuildTemplate?: (
        loop: LoopBuilder<any, any>
      ) => void;
      options?: any;
    }> = [];

    const builder: WorkflowBuilder = {
      step(title, fn, options) {
        items.push({ type: "step", title, fn, options });
      },
      group(title, buildFn, options) {
        items.push({ type: "group", title, buildFn, options });
      },
      map<T>(
        title: string,
        opts: MapOptions<T>,
        buildTemplate: (loop: LoopBuilder<any, T>) => void
      ) {
        items.push({
          type: "map",
          title,
          mapOpts: opts,
          mapBuildTemplate: buildTemplate,
        });
      },
    };

    buildFn(builder);

    for (const item of items) {
      if (isCancelled) break;

      const logicalPath = parentPath
        ? `${parentPath}/${item.title}`
        : item.title;
      const nodeId = generateNodeId(version, logicalPath);
      const nodeTitle = item.title;

      // Check for pause/cancel before each step
      await waitIfPausedHelper(nodeId);
      if (isCancelled) break;

      if (item.type === "step" && item.fn) {
        const retryOpts = item.options?.retry;
        const maxAttempts = retryOpts?.maxAttempts ?? 1;
        const backoffMs = retryOpts?.backoffMs ?? 0;

        let attempt = 0;
        let lastError: any = null;

        while (attempt < maxAttempts) {
          attempt++;
          if (attempt > 1 && backoffMs > 0) {
            await sleepHelper(backoffMs, nodeId);
          }

          onEvent({
            type: "node:start",
            nodeId,
            nodeTitle,
            at: new Date().toISOString(),
            attempt,
            maxAttempts,
          });

          const ctx: import("./types.js").StepContext = {
            nodeId,
            runId,
            inputs,
            log: createLogInterface(nodeId, nodeTitle),
            progress: (p) =>
              onEvent({ type: "node:progress", nodeId, nodeTitle, data: p }),
            artifact: (a) =>
              onEvent({ type: "node:artifact", nodeId, nodeTitle, data: a }),
            output: (o) => {
              outputs[nodeId] = o;
              onEvent({
                type: "node:output",
                nodeId,
                nodeTitle,
                runId,
                data: o,
                at: new Date().toISOString(),
              });
            },
            isCancelled: () => isCancelled,
            throwIfCancelled: () => {
              if (isCancelled) throw new Error("Cancelled");
            },
            isPaused: () => isPaused,
            waitIfPaused: async () => await waitIfPausedHelper(nodeId),
            sleep: async (ms) => await sleepHelper(ms, nodeId),
            run: createRunStore(),
            attempt,
            maxAttempts,
          };

          try {
            await item.fn(ctx);
            onEvent({
              type: "node:end",
              nodeId,
              nodeTitle,
              status: "success",
              at: new Date().toISOString(),
            });
            // Remove from failed steps if it was there (retry success)
            const failedIndex = failedSteps.findIndex((f) => f.nodeId === nodeId);
            if (failedIndex >= 0) {
              failedSteps.splice(failedIndex, 1);
              emitControlState();
            }
            lastError = null;
            break; // Success!
          } catch (e: any) {
            lastError = e;
            if (attempt < maxAttempts) {
              // Emit retry event or just log
              onEvent({
                type: "node:log",
                nodeId,
                nodeTitle,
                level: "warn",
                msg: `Step failed, retrying (${attempt}/${maxAttempts}): ${e.message}`,
                at: new Date().toISOString(),
              });
              continue;
            }

            onEvent({
              type: "node:end",
              nodeId,
              nodeTitle,
              status: "failure",
              error: e.message,
              at: new Date().toISOString(),
            });
            // Track failed step
            const existingFailed = failedSteps.find((f) => f.nodeId === nodeId);
            if (existingFailed) {
              existingFailed.error = e.message;
            } else {
              failedSteps.push({ nodeId, error: e.message });
            }
            emitControlState();
          }
        }

        if (lastError) {
          throw lastError;
        }
      }
      else if (item.type === "group" && item.buildFn) {
        onEvent({
          type: "node:start",
          nodeId,
          nodeTitle,
          at: new Date().toISOString(),
        });

        try {
          await traverseAndExecute(item.buildFn, logicalPath, nodeId);
          onEvent({
            type: "node:end",
            nodeId,
            nodeTitle,
            status: "success",
            at: new Date().toISOString(),
          });
        } catch (e: any) {
          onEvent({
            type: "node:end",
            nodeId,
            nodeTitle,
            status: "failure",
            error: e.message,
            at: new Date().toISOString(),
          });
          throw e;
        }
      } else if (item.type === "map" && item.mapOpts && item.mapBuildTemplate) {
        // ─────────────────────────────────────────────────────────────────────
        // Map node execution
        // ─────────────────────────────────────────────────────────────────────
        const mapNodeId = nodeId;
        const mapOpts = item.mapOpts;
        const buildTemplate = item.mapBuildTemplate;
        const onError = mapOpts.onError ?? "fail-fast";

        // Emit node:start for the map node (so existing UI status works)
        onEvent({
          type: "node:start",
          nodeId: mapNodeId,
          nodeTitle,
          at: new Date().toISOString(),
        });

        // Collect template steps by calling buildTemplate in "template mode"
        const templateSteps: Array<{
          title: string;
          fn: IterationStepFn<any, any>;
          options?: StepNodeOptions;
          nodeId: string;
        }> = [];

        const loopBuilder: LoopBuilder<any, any> = {
          step(
            stepTitle: string,
            fn: IterationStepFn<any, any>,
            stepOptions?: StepNodeOptions
          ) {
            const templateLogicalPath = `${logicalPath}/${stepTitle}`;
            const templateNodeId = generateNodeId(version, templateLogicalPath);
            templateSteps.push({
              title: stepTitle,
              fn,
              options: stepOptions,
              nodeId: templateNodeId,
            });
          },
        };

        // Discover template structure
        buildTemplate(loopBuilder);

        let mapError: Error | null = null;
        let mapStatus: "success" | "failed" | "canceled" = "success";

        try {
          // Create context for items() evaluation
          const mapItemsCtx: import("./types.js").MapItemsContext = {
            runId,
            inputs,
            run: createRunStore(),
            log: createLogInterface(mapNodeId, nodeTitle),
          };

          // Evaluate items at runtime
          const itemsResult = await mapOpts.items(mapItemsCtx);
          const itemsArray = Array.isArray(itemsResult) ? itemsResult : [];
          const total = itemsArray.length;

          // Initialize counts
          const counts: import("./types.js").MapCounts = {
            total,
            pending: total,
            running: 0,
            completed: 0,
            failed: 0,
            skipped: 0,
          };

          // Emit map:start
          onEvent({
            type: "map:start",
            runId,
            mapNodeId,
            total,
            at: new Date().toISOString(),
            counts: { ...counts },
          });

          // Sequential iteration
          for (let i = 0; i < itemsArray.length; i++) {
            if (isCancelled) {
              mapStatus = "canceled";
              // Mark remaining as skipped
              counts.skipped += counts.pending;
              counts.pending = 0;
              break;
            }

            const currentItem = itemsArray[i];
            // Compute display key (user-provided or index fallback)
            const key = mapOpts.key?.(currentItem, i);
            // Generate stable, scoped iterationId
            const iterationId =
              key !== undefined
                ? `${mapNodeId}:${hashKey(key)}`
                : `${mapNodeId}:${i}`;
            const itemStartTime = Date.now();

            // Update counts
            counts.pending--;
            counts.running = 1;

            // Emit map:item:start
            onEvent({
              type: "map:item:start",
              runId,
              mapNodeId,
              at: new Date().toISOString(),
              iterationId,
              index: i,
              key,
            });

            // Emit progress with spotlight
            onEvent({
              type: "map:progress",
              runId,
              mapNodeId,
              at: new Date().toISOString(),
              counts: { ...counts },
              spotlight: {
                iterationId,
                index: i,
                key,
                activeTemplateNodeId: templateSteps[0]?.nodeId,
              },
            });

            let iterationFailed = false;
            let iterationError:
              | import("./types.js").SerializedError
              | undefined;

            // Execute template steps for this iteration
            for (const templateStep of templateSteps) {
              if (isCancelled) break;

              // Check for pause/cancel before each template step
              await waitIfPausedHelper(templateStep.nodeId);
              if (isCancelled) break;

              const retryOpts = templateStep.options?.retry;
              const maxAttempts = retryOpts?.maxAttempts ?? 1;
              const backoffMs = retryOpts?.backoffMs ?? 0;

              let attempt = 0;
              let stepSucceeded = false;

              while (attempt < maxAttempts) {
                attempt++;
                const templateStepStartTime = Date.now();
                if (attempt > 1 && backoffMs > 0) {
                  await sleepHelper(backoffMs, templateStep.nodeId);
                }

                // Emit map:templateStep:start
                onEvent({
                  type: "map:templateStep:start",
                  runId,
                  mapNodeId,
                  at: new Date().toISOString(),
                  iterationId,
                  templateNodeId: templateStep.nodeId,
                  attempt,
                  maxAttempts,
                });

                // Update spotlight
                onEvent({
                  type: "map:progress",
                  runId,
                  mapNodeId,
                  at: new Date().toISOString(),
                  counts: { ...counts },
                  spotlight: {
                    iterationId,
                    index: i,
                    key,
                    activeTemplateNodeId: templateStep.nodeId,
                  },
                });

                // Create step context with loop info and iteration store
                const stepCtx: IterationStepContext = {
                  nodeId: templateStep.nodeId,
                  runId,
                  inputs,
                  log: createLogInterface(
                    templateStep.nodeId,
                    templateStep.title
                  ),
                  progress: (p) =>
                    onEvent({
                      type: "node:progress",
                      nodeId: templateStep.nodeId,
                      nodeTitle: templateStep.title,
                      data: p,
                    }),
                  artifact: (a) =>
                    onEvent({
                      type: "node:artifact",
                      nodeId: templateStep.nodeId,
                      nodeTitle: templateStep.title,
                      data: a,
                    }),
                  output: (o) => {
                    if (!mapOutputs[mapNodeId]) mapOutputs[mapNodeId] = {};
                    if (!mapOutputs[mapNodeId][iterationId])
                      mapOutputs[mapNodeId][iterationId] = {};
                    mapOutputs[mapNodeId][iterationId][templateStep.nodeId] = o;

                    onEvent({
                      type: "node:output",
                      nodeId: templateStep.nodeId,
                      nodeTitle: templateStep.title,
                      runId,
                      mapNodeId,
                      iterationId,
                      data: o,
                      at: new Date().toISOString(),
                    });
                  },
                  isCancelled: () => isCancelled,
                  throwIfCancelled: () => {
                    if (isCancelled) throw new Error("Cancelled");
                  },
                  isPaused: () => isPaused,
                  waitIfPaused: async () =>
                    await waitIfPausedHelper(templateStep.nodeId),
                  sleep: async (ms) =>
                    await sleepHelper(ms, templateStep.nodeId),
                  run: createIterationStore(iterationId),
                  loop: {
                    mapNodeId,
                    iterationId,
                    index: i,
                    key,
                    item: currentItem,
                  },
                  iteration: createIterationStore(iterationId),
                  attempt,
                  maxAttempts,
                };

                try {
                  await templateStep.fn(stepCtx);

                  // Emit map:templateStep:end success
                  onEvent({
                    type: "map:templateStep:end",
                    runId,
                    mapNodeId,
                    at: new Date().toISOString(),
                    iterationId,
                    templateNodeId: templateStep.nodeId,
                    status: "success",
                    durationMs: Date.now() - templateStepStartTime,
                  });
                  stepSucceeded = true;
                  break;
                } catch (e: any) {
                  if (attempt < maxAttempts) {
                    onEvent({
                      type: "map:log",
                      runId,
                      mapNodeId,
                      at: new Date().toISOString(),
                      iterationId,
                      templateNodeId: templateStep.nodeId,
                      level: "warn",
                      message: `Step failed, retrying (${attempt}/${maxAttempts}): ${e.message}`,
                    });
                    continue;
                  }

                  // Emit map:templateStep:end failed
                  onEvent({
                    type: "map:templateStep:end",
                    runId,
                    mapNodeId,
                    at: new Date().toISOString(),
                    iterationId,
                    templateNodeId: templateStep.nodeId,
                    status: "failed",
                    durationMs: Date.now() - templateStepStartTime,
                    error: { message: e.message, stack: e.stack },
                  });

                  iterationFailed = true;
                  iterationError = { message: e.message, stack: e.stack };
                  break;
                }
              }

              if (!stepSucceeded) {
                if (onError === "fail-fast") {
                  mapError = new Error(iterationError?.message || "Step failed");
                  break;
                }
                break;
              }
            }

            // Update counts after iteration
            counts.running = 0;
            if (iterationFailed) {
              counts.failed++;
            } else if (!isCancelled) {
              counts.completed++;
            }

            // Emit map:item:end (includes index/key for UI consumption)
            onEvent({
              type: "map:item:end",
              runId,
              mapNodeId,
              at: new Date().toISOString(),
              iterationId,
              index: i,
              key,
              status: iterationFailed
                ? "failed"
                : isCancelled
                  ? "skipped"
                  : "success",
              durationMs: Date.now() - itemStartTime,
              error: iterationError,
            });

            // Clear iteration-scoped store to avoid memory buildup
            clearIterationStore(iterationId);

            // Emit progress after item completion
            onEvent({
              type: "map:progress",
              runId,
              mapNodeId,
              at: new Date().toISOString(),
              counts: { ...counts },
            });

            // If fail-fast and we have an error, stop
            if (mapError && onError === "fail-fast") {
              mapStatus = "failed";
              // Mark remaining as skipped
              counts.skipped += counts.pending;
              counts.pending = 0;
              break;
            }
          }

          // Determine final status
          if (isCancelled) {
            mapStatus = "canceled";
          } else if (counts.failed > 0) {
            mapStatus = "failed";
          }

          // Emit map:end
          onEvent({
            type: "map:end",
            runId,
            mapNodeId,
            at: new Date().toISOString(),
            status: mapStatus,
            counts: { ...counts },
          });
        } catch (e: any) {
          // Handle error during items() evaluation or other unexpected errors
          mapError = e;
          mapStatus = "failed";

          onEvent({
            type: "map:end",
            runId,
            mapNodeId,
            at: new Date().toISOString(),
            status: "failed",
            counts: {
              total: 0,
              pending: 0,
              running: 0,
              completed: 0,
              failed: 1,
              skipped: 0,
            },
          });
        }

        // Emit node:end for the map node
        if (mapStatus === "success") {
          onEvent({
            type: "node:end",
            nodeId: mapNodeId,
            nodeTitle,
            status: "success",
            at: new Date().toISOString(),
          });
        } else {
          onEvent({
            type: "node:end",
            nodeId: mapNodeId,
            nodeTitle,
            status: "failure",
            error: mapError?.message ?? `Map ${mapStatus}`,
            at: new Date().toISOString(),
          });

          // If fail-fast and we have an error, propagate it
          if (mapError && (mapOpts.onError ?? "fail-fast") === "fail-fast") {
            throw mapError;
          }
        }
      }
    }
  };

  try {
    const rootId = "root";
    onEvent({
      type: "node:start",
      nodeId: rootId,
      nodeTitle: def.name,
      at: new Date().toISOString(),
    });
    await traverseAndExecute(def.build, "", rootId);
    onEvent({
      type: "node:end",
      nodeId: rootId,
      nodeTitle: def.name,
      status: "success",
      at: new Date().toISOString(),
    });
  } catch (e) {
    const rootId = "root";
    onEvent({
      type: "node:end",
      nodeId: rootId,
      nodeTitle: def.name,
      status: "failure",
      at: new Date().toISOString(),
    });
    throw e;
  }
}
